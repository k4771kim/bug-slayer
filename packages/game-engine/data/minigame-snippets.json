{
  "conflicts": [
    {
      "id": "conflict-01",
      "title": "Null Safety",
      "head": "if (user !== null) {\n  return user.name;\n}",
      "incoming": "if (user) {\n  return user.Name;\n}",
      "options": [
        "if (user !== null) {\n  return user.name;\n}",
        "if (user) {\n  return user.Name;\n}",
        "if (user != null) {\n  return user.Name;\n}"
      ],
      "correctIndex": 0,
      "hint": "Use strict equality and correct property casing"
    },
    {
      "id": "conflict-02",
      "title": "Loop Bounds",
      "head": "for (let i = 0; i < arr.length; i++)",
      "incoming": "for (let i = 0; i <= arr.length; i++)",
      "options": [
        "for (let i = 0; i < arr.length; i++)",
        "for (let i = 0; i <= arr.length; i++)",
        "for (let i = 1; i < arr.length; i++)",
        "for (let i = 0; i < arr.length - 1; i++)"
      ],
      "correctIndex": 0,
      "hint": "Off-by-one: use < not <= with .length"
    },
    {
      "id": "conflict-03",
      "title": "SQL Query",
      "head": "db.query('SELECT * FROM users WHERE id = ?', [id]);",
      "incoming": "db.query(`SELECT * FROM users WHERE id = ${id}`);",
      "options": [
        "db.query('SELECT * FROM users WHERE id = ?', [id]);",
        "db.query(`SELECT * FROM users WHERE id = ${id}`);",
        "db.query('SELECT * FROM users WHERE id = ' + id);"
      ],
      "correctIndex": 0,
      "hint": "Use parameterized queries to prevent SQL injection"
    },
    {
      "id": "conflict-04",
      "title": "XSS Prevention",
      "head": "el.textContent = userInput;",
      "incoming": "el.innerHTML = userInput;",
      "options": [
        "el.textContent = userInput;",
        "el.innerHTML = userInput;",
        "el.innerHTML = escapeHtml(userInput);",
        "el.outerHTML = userInput;"
      ],
      "correctIndex": 0,
      "hint": "Use textContent to safely render user input"
    },
    {
      "id": "conflict-05",
      "title": "Error Handling",
      "head": "try {\n  return await api.get('/data');\n} catch (err) {\n  log(err);\n}",
      "incoming": "return await api.get('/data');",
      "options": [
        "try {\n  return await api.get('/data');\n} catch (err) {\n  log(err);\n}",
        "return await api.get('/data');",
        "return api.get('/data').catch(() => {});"
      ],
      "correctIndex": 0,
      "hint": "Always handle errors in async functions"
    },
    {
      "id": "conflict-06",
      "title": "Memory Leak",
      "head": "btn.addEventListener('click', handler);\n// cleanup:\nbtn.removeEventListener('click', handler);",
      "incoming": "btn.addEventListener('click', handler);",
      "options": [
        "btn.addEventListener('click', handler);\nbtn.removeEventListener('click', handler);",
        "btn.addEventListener('click', handler);",
        "btn.onclick = handler;",
        "btn.addEventListener('click', () => handler());"
      ],
      "correctIndex": 0,
      "hint": "Remove event listeners to prevent memory leaks"
    },
    {
      "id": "conflict-07",
      "title": "Variable Scope",
      "head": "let counter = 0;",
      "incoming": "var counter = 0;",
      "options": [
        "let counter = 0;",
        "var counter = 0;",
        "counter = 0;"
      ],
      "correctIndex": 0,
      "hint": "Use let/const instead of var for block scoping"
    },
    {
      "id": "conflict-08",
      "title": "Async Parallel",
      "head": "await Promise.all([fetch(a), fetch(b)]);",
      "incoming": "await fetch(a);\nawait fetch(b);",
      "options": [
        "await Promise.all([fetch(a), fetch(b)]);",
        "await fetch(a);\nawait fetch(b);",
        "Promise.all([fetch(a), fetch(b)]);",
        "fetch(a); fetch(b);"
      ],
      "correctIndex": 0,
      "hint": "Use Promise.all for parallel async operations"
    },
    {
      "id": "conflict-09",
      "title": "Type Check",
      "head": "if (typeof val === 'undefined') {",
      "incoming": "if (val == undefined) {",
      "options": [
        "if (typeof val === 'undefined') {",
        "if (val == undefined) {",
        "if (val === undefined) {",
        "if (!val) {"
      ],
      "correctIndex": 0,
      "hint": "typeof check is safest for undefined values"
    },
    {
      "id": "conflict-10",
      "title": "Array Transform",
      "head": "const doubled = nums.map(n => n * 2);",
      "incoming": "const doubled = [];\nfor (let i = 0; i < nums.length; i++)\n  doubled[i] = nums[i] * 2;",
      "options": [
        "const doubled = nums.map(n => n * 2);",
        "const doubled = [];\nfor (let i ...) doubled[i] = nums[i] * 2;",
        "const doubled = nums.forEach(n => n * 2);"
      ],
      "correctIndex": 0,
      "hint": "Use .map() for clean array transformations"
    },
    {
      "id": "conflict-11",
      "title": "Race Condition",
      "head": "await mutex.acquire();\ntry { shared++; }\nfinally { mutex.release(); }",
      "incoming": "shared++;",
      "options": [
        "await mutex.acquire();\ntry { shared++; }\nfinally { mutex.release(); }",
        "shared++;",
        "await lock();\nshared++;",
        "synchronized { shared++; }"
      ],
      "correctIndex": 0,
      "hint": "Use mutex locks for shared state access"
    },
    {
      "id": "conflict-12",
      "title": "Object Clone",
      "head": "const copy = { ...obj };",
      "incoming": "const copy = obj;",
      "options": [
        "const copy = { ...obj };",
        "const copy = obj;",
        "const copy = Object.assign(obj);",
        "const copy = obj.clone();"
      ],
      "correctIndex": 0,
      "hint": "Spread operator creates a shallow clone"
    },
    {
      "id": "conflict-13",
      "title": "Switch Default",
      "head": "switch (s) {\n  case 'a': return 1;\n  default: throw Error('unknown');\n}",
      "incoming": "switch (s) {\n  case 'a': return 1;\n}",
      "options": [
        "switch (s) {\n  case 'a': return 1;\n  default: throw Error('unknown');\n}",
        "switch (s) {\n  case 'a': return 1;\n}",
        "switch (s) {\n  case 'a': return 1;\n  default: break;\n}"
      ],
      "correctIndex": 0,
      "hint": "Always add a default case to catch unknowns"
    },
    {
      "id": "conflict-14",
      "title": "parseInt Radix",
      "head": "const val = parseInt(input, 10);",
      "incoming": "const val = parseInt(input);",
      "options": [
        "const val = parseInt(input, 10);",
        "const val = parseInt(input);",
        "const val = Number(input);",
        "const val = +input;"
      ],
      "correctIndex": 0,
      "hint": "Always specify radix in parseInt"
    },
    {
      "id": "conflict-15",
      "title": "Timer Cleanup",
      "head": "componentWillUnmount() {\n  clearInterval(this.timer);\n}",
      "incoming": "// no cleanup",
      "options": [
        "componentWillUnmount() {\n  clearInterval(this.timer);\n}",
        "// no cleanup needed",
        "componentWillUnmount() {\n  this.timer = null;\n}"
      ],
      "correctIndex": 0,
      "hint": "Clean up timers in lifecycle methods"
    },
    {
      "id": "conflict-16",
      "title": "JSON Parse",
      "head": "try {\n  data = JSON.parse(input);\n} catch { handleError(); }",
      "incoming": "data = JSON.parse(input);",
      "options": [
        "try {\n  data = JSON.parse(input);\n} catch { handleError(); }",
        "data = JSON.parse(input);",
        "data = JSON.parse(input) || {};",
        "data = eval(input);"
      ],
      "correctIndex": 0,
      "hint": "Always wrap JSON.parse in try-catch"
    },
    {
      "id": "conflict-17",
      "title": "Array Search",
      "head": "const r = items.find(i => i.id === target);",
      "incoming": "let r = null;\nfor (let i = 0; i < items.length; i++)\n  if (items[i].id === target) r = items[i];",
      "options": [
        "const r = items.find(i => i.id === target);",
        "let r; for (...) if (items[i].id === target) r = items[i];",
        "const r = items.filter(i => i.id === target);",
        "const r = items.indexOf(target);"
      ],
      "correctIndex": 0,
      "hint": "Use .find() for single-element search"
    },
    {
      "id": "conflict-18",
      "title": "Config Immutability",
      "head": "const cfg = Object.freeze({ URL: '...' });",
      "incoming": "const cfg = { URL: '...' };",
      "options": [
        "const cfg = Object.freeze({ URL: '...' });",
        "const cfg = { URL: '...' };",
        "let cfg = { URL: '...' };",
        "var cfg = Object.freeze({ URL: '...' });"
      ],
      "correctIndex": 0,
      "hint": "Freeze config objects to prevent mutation"
    },
    {
      "id": "conflict-19",
      "title": "Equality Check",
      "head": "if (a === b && typeof a === 'number')",
      "incoming": "if (a == b)",
      "options": [
        "if (a === b && typeof a === 'number')",
        "if (a == b)",
        "if (a === b)",
        "if (a >= b && a <= b)"
      ],
      "correctIndex": 0,
      "hint": "Strict equality with type guard is safest"
    },
    {
      "id": "conflict-20",
      "title": "Promise Chain",
      "head": "fetch(url)\n  .then(r => r.json())\n  .catch(err => log(err));",
      "incoming": "fetch(url)\n  .then(r => r.json());",
      "options": [
        "fetch(url)\n  .then(r => r.json())\n  .catch(err => log(err));",
        "fetch(url)\n  .then(r => r.json());",
        "fetch(url).then(r => r.text());",
        "fetch(url).catch(err => log(err));"
      ],
      "correctIndex": 0,
      "hint": "Always add .catch() to promise chains"
    }
  ]
}
